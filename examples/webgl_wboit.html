<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - weighted blended order-independent transparency</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				background-color: #000000;
				margin: 0px;
				overflow: hidden;
				font-family:Monospace;
				font-size:13px;
				text-align:center;
				font-weight: bold;
				text-align:center;
			}

			a {
				color:#0078ff;
			}

			#info {
				color:#fff;

				top: 0px;

				position: absolute;
				padding: 5px;
				width: 500px;
				z-index: 5;

				left: 50px;

			}
		</style>
	</head>

	<body>
		<script src="../build/three.min.js"></script>


		<script src="js/Detector.js"></script>
		<script src="js/libs/stats.min.js"></script>

		<div id="info">
			<a href="http://threejs.org" target="_blank">three.js</a> - webgl weighted blended order-independent transparency
		</div>

		<script id="combineVS" type="x-shader/x-vertex">

			varying vec2 vUv;

			void main()	{

				gl_Position = vec4( position, 1.0 );
				vUv = 0.5 + 0.5 * position.xy;

			}

		</script>

		<script id="combineFS" type="x-shader/x-fragment">

			uniform sampler2D accumTex;
			uniform sampler2D revealageTex;

			varying vec2 vUv;

			void main()	{

				vec4 accum = texture2D( accumTex, vUv );
				float r = accum.a;
				accum.a = texture2D( revealageTex, vUv ).r;
				gl_FragColor = vec4( accum.rgb / accum.a, r );

			}

		</script>

		<script>

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var container, stats, frameCounter = 0;
			var camera, scene, renderer;

			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;

			var mouse = new THREE.Vector2();

			var target = new THREE.Vector3();
			var skyboxMesh;
			var transparentRoot, opaqueRoot;

			var quadCam, quadMesh;

			var SCALE = 2;
			var accumMat, revealageMat;
			var rtAccum, rtRevealage;

			var NUM_MONKEYS = 5;
			var balls = [], NUM_BALLS = 5;

			init();
			animate();

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 37, window.innerWidth / window.innerHeight, 1, 2000 );

				scene = new THREE.Scene();

				renderer = new THREE.WebGLRenderer( { antialias: false } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.sortObjects = false;
				renderer.autoClear = renderer.autoClearColor = renderer.autoClearDepth = renderer.autoClearStencil = false;
				container.appendChild( renderer.domElement );

				//

				var r = "textures/cube/Bridge2/";
				var urls = [ r + "posx.jpg", r + "negx.jpg",
							 r + "posy.jpg", r + "negy.jpg",
							 r + "posz.jpg", r + "negz.jpg" ];

				var textureCube = THREE.ImageUtils.loadTextureCube( urls  );
				textureCube.format = THREE.RGBFormat;

				transparentRoot = new THREE.Object3D();
				scene.add( transparentRoot );
				opaqueRoot = new THREE.Object3D();
				scene.add( opaqueRoot );

				// Skybox

				var shader = THREE.ShaderLib[ "cube" ];
				shader.uniforms[ "tCube" ].value = textureCube;

				var skyboxMat = new THREE.ShaderMaterial( {

					fragmentShader: shader.fragmentShader,
					vertexShader: shader.vertexShader,
					uniforms: shader.uniforms,
					depthWrite: false,
					side: THREE.BackSide

				} );

				skyboxMesh = new THREE.Mesh( new THREE.BoxGeometry( 1000, 1000, 1000 ), skyboxMat );
				opaqueRoot.add( skyboxMesh );

				// Rendertargets

				rtAccum = new THREE.WebGLRenderTarget( window.innerWidth / SCALE, window.innerHeight / SCALE, {
					minFilter: THREE.NearestFilter,
					magFilter: THREE.NearestFilter,
					format: THREE.RGBAFormat,
					type: THREE.FloatType,
					generateMipmaps: false,
					depthBuffer: false,
					stencilBuffer: false
				} );

				rtRevealage = new THREE.WebGLRenderTarget( window.innerWidth / SCALE, window.innerHeight / SCALE, {
					minFilter: THREE.NearestFilter,
					magFilter: THREE.NearestFilter,
					format: THREE.RGBFormat,
					type: THREE.FloatType,
					generateMipmaps: false,
					depthBuffer: false,
					stencilBuffer: false
				} );

				// Materials

				accumMat = new THREE.MeshPhongMaterial( {
					color: 0xffffff,
					specular:0xffffff,
					envMap: textureCube,
					combine: THREE.MultiplyOperation,
					shininess: 20,
					reflectivity: 0.98,
					side: THREE.DoubleSide,
					transparent: true,
					depthWrite: false,
					depthTest: false,
					blending: THREE.CustomBlending,
					blendSrc: THREE.OneFactor,
					blendDst: THREE.OneFactor,
					blendSrcAlpha: THREE.ZeroFactor,
					blendDstAlpha: THREE.OneMinusSrcAlphaFactor
				} );
				accumMat.defines = {
					EPILOG:
						"float w = 1e-9 + (1.0 - 1e-9) * pow( 1.0 + (gl_FragCoord.z / gl_FragCoord.w) / 2000.0, -5.0 );" +
						"float ai = 0.98 * gl_FragColor.a;" +
						"vec3 Ci = 1.2 * ai * gl_FragColor.rgb;" +
						"gl_FragColor = w * vec4( w * Ci, ai );"
				};

				revealageMat = new THREE.MeshPhongMaterial( {
					color: 0xffffff,
					specular:0xffffff,
					envMap: textureCube,
					combine: THREE.MultiplyOperation,
					shininess: 20,
					reflectivity: 0.98,
					side: THREE.DoubleSide,
					transparent: true,
					depthWrite: false,
					depthTest: false,
					blending: THREE.CustomBlending,
					blendSrc: THREE.OneFactor,
					blendDst: THREE.OneFactor,
					blendSrcAlpha: THREE.ZeroFactor,
					blendDstAlpha: THREE.OneMinusSrcAlphaFactor
				} );
				revealageMat.defines = {
					EPILOG:
						"float w = 1e-9 + (1.0 - 1e-9) * pow( 1.0 + (gl_FragCoord.z / gl_FragCoord.w) / 2000.0, -5.0 );" +
						"float ai = 0.98 * gl_FragColor.a;" +
						"gl_FragColor = vec4( vec3( w * ai ), 1.0 );"
				};

				var combineUnif = {
					accumTex: { type: 't', value: rtAccum },
					revealageTex: { type: 't', value: rtRevealage }
				};
				var combineMat = new THREE.ShaderMaterial( {
					uniforms: combineUnif,
					vertexShader: document.getElementById( 'combineVS' ).textContent,
					fragmentShader: document.getElementById( 'combineFS' ).textContent,
					transparent: true,
					blending: THREE.CustomBlending,
					blendSrc: THREE.OneMinusSrcAlphaFactor,
					blendDst: THREE.SrcAlphaFactor
				} );

				// Full-screen quad

				quadCam = new THREE.OrthographicCamera( -1, 1, 1, -1, 0, 1 );
				quadMesh = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2, 2 ), combineMat );

				// Adding Monkeys

				var loader2 = new THREE.JSONLoader();
				loader2.load( 'obj/Suzanne.js', function ( geometry ) {

					for ( var i = 0; i < NUM_MONKEYS; i ++ ) {

						var mesh = new THREE.Mesh( geometry, accumMat );
						mesh.scale.multiplyScalar(30);

						mesh.position.z = Math.cos(i / NUM_MONKEYS * Math.PI * 2) * 60;
						mesh.position.y = 0;
						mesh.position.x = Math.sin(i / NUM_MONKEYS * Math.PI * 2) * 60;

						mesh.rotation.x = Math.PI / 2;
						mesh.rotation.z = 0.0 + -i / NUM_MONKEYS * Math.PI * 2;

						transparentRoot.add( mesh );

					}

				} );

				// Add Balls
//				var geometry = new THREE.SphereGeometry( 4, 10, 10 );
				var geometry = new THREE.CubeGeometry( 4, 4, 4 );

				for ( var i = 0; i < NUM_BALLS; i ++ ) {

					var mesh = new THREE.Mesh( geometry, accumMat );

					mesh.position.set(
						(Math.random() - 0.5) * 40,
						Math.random() * 20,
						(Math.random() - 0.5)  * 40
					);

					mesh.scale.multiplyScalar(10);
//					opaqueRoot.add( mesh );

					mesh.velocity = new THREE.Vector3(
						4 * Math.random() - 2,
						4 * Math.random() - 2,
						4 * Math.random() - 2
					);
					balls.push( mesh );

				}

				// Lights

				scene.add( new THREE.AmbientLight( 0x222222 ) );

				directionalLight = new THREE.DirectionalLight( 0xffffff, 2 );
				directionalLight.position.set( 2, 1.2, 10 ).normalize();
				scene.add( directionalLight );

				directionalLight = new THREE.DirectionalLight( 0xffffff, 1 );
				directionalLight.position.set( -2, 1.2, -10 ).normalize();
				scene.add( directionalLight );

				renderer.autoClear = false;

				renderer.domElement.style.position = 'absolute';
				renderer.domElement.style.left = "0px";

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				container.appendChild( stats.domElement );

				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				document.addEventListener( 'touchstart', onDocumentTouchStart, false );
				document.addEventListener( 'touchmove', onDocumentTouchMove, false );

				window.addEventListener( 'resize', onWindowResize, false );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function onDocumentMouseMove( event ) {

				mouse.x = ( event.clientX - windowHalfX ) / windowHalfX;
				mouse.y = - ( event.clientY - windowHalfY ) / windowHalfY;

			}

			function onDocumentTouchStart( event ) {

				if ( event.touches.length == 1 ) {

					event.preventDefault();

					mouse.x = ( event.touches[ 0 ].pageX - windowHalfX ) / windowHalfX;
					mouse.y = - ( event.touches[ 0 ].pageY - windowHalfY ) / windowHalfY;

				}
			}

			function onDocumentTouchMove( event ) {

				if ( event.touches.length == 1 ) {

					event.preventDefault();

					mouse.x = ( event.touches[ 0 ].pageX - windowHalfX ) / windowHalfX;
					mouse.y = - ( event.touches[ 0 ].pageY - windowHalfY ) / windowHalfY;

				}

			}

			function animate() {

				requestAnimationFrame( animate, renderer.domElement );

				render();
				stats.update();

				frameCounter ++;

			}

			function render() {

				var t = 0.06 * frameCounter / 20;

				camera.position.x = Math.cos(t) * 200;
				camera.position.z = Math.sin(t) * 200;
				camera.position.y = Math.sin(1.5 * t) * 40;

				camera.lookAt( target );

				var temp = new THREE.Vector3();

				for (var i = 0; i < balls.length; i ++ ) {

					var ball = balls[ i ];
					ball.position.add( ball.velocity );
					temp.copy( ball.position ); 
					temp.multiplyScalar( 0.1 / temp.length() );
					ball.velocity.sub( temp );

				} 

				renderer.setClearColor( 0x000000, 1 );

				opaqueRoot.visible = false;
				transparentRoot.visible = true;
				scene.overrideMaterial = accumMat;
				renderer.clearTarget( rtAccum, true, false, false );
				renderer.render( scene, camera, rtAccum );

				scene.overrideMaterial = revealageMat;
				renderer.clearTarget( rtRevealage, true, false, false );
				renderer.render( scene, camera, rtRevealage );

				opaqueRoot.visible = true;
				transparentRoot.visible = false;
				scene.overrideMaterial = null;
				renderer.render( scene, camera );

				renderer.render( quadMesh, quadCam );

			}


		</script>
	</body>
</html>
