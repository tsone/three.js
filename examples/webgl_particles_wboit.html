<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - weighted blended order-independent transparency</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				background-color: #000000;
				margin: 0px;
				overflow: hidden;
				font-family:Monospace;
				font-size:13px;
				text-align:center;
				font-weight: bold;
				text-align:center;
			}

			a {
				color:#0078ff;
			}

			#info {
				color:#fff;
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
				z-index:100;
			}

		</style>
	</head>
	<body>

		<div id="info">
			<a href="http://threejs.org" target="_blank">three.js</a> - webgl weighted blended order-independent transparency - <a href="http://jcgt.org/published/0002/02/09/" target="_blank">paper</a><br/>
			<input type="checkbox" checked onclick="toggleBox();">show opaque background</>
		</div>

		<script src="../build/three.js"></script>

		<script src="js/Detector.js"></script>
		<script src="js/libs/stats.min.js"></script>

		<script id="particleVS" type="x-shader/x-vertex">

			uniform float particleScale;
			uniform float particleSize;
			uniform float far;
			uniform float near;

			varying float depth;

			void main()
			{

				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				depth = gl_Position.z * (far-near) / far + near;

				float attenuation = 1.0 / (gl_Position.z * gl_Position.z);
				gl_PointSize = particleSize * particleScale * attenuation;

			}

		</script>

		<script id="particleFS" type="x-shader/x-fragment">

			#extension GL_EXT_draw_buffers : require

			uniform sampler2D texture;
			uniform sampler2D depthTex;
			uniform vec2 invResolution;
			uniform float softenCoeff;

			varying float depth;

			float unpackDepth( const in vec4 rgba_depth ) {

				const vec4 bit_shift = vec4( 1.0 / ( 256.0*256.0*256.0 ), 1.0 / ( 256.0*256.0 ), 1.0 / 256.0, 1.0 );
				float depth = dot( rgba_depth, bit_shift );
				return depth;

			}

			void main( void ) {

				vec4 color = texture2D( texture, gl_PointCoord );
				// Depth was encoded as 1/1000, so we need to scale it back.
				float bgDepth = 1000.0 * unpackDepth( texture2D( depthTex, gl_FragCoord.xy * invResolution ) );
				float soften = min( softenCoeff * (bgDepth - depth), 1.0 );
				// Apply alpha to RGB (not premultiplied) and soften. Particles are max. 50% opaque.
				color = 0.5*soften*color.a * vec4( color.rgb, 1.0 ); 
				float w = 1e-9 + (1.0 - 1e-9) * pow( 1.0 + depth, -5.0 );
				gl_FragData[0] = vec4( w * color.rgb, color.a );
				gl_FragData[1].r = w * color.a;

			}

		</script>

		<script id="depthVS" type="x-shader/x-vertex">

			void main()
			{
				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			}

		</script>

		<script id="depthFS" type="x-shader/x-fragment">

			vec4 packDepth( const in float depth ) {

				const vec4 bit_shift = vec4( 256.0*256.0*256.0, 256.0*256.0, 256.0, 1.0 );
				const vec4 bit_mask = vec4( 0.0, 1.0/256.0, 1.0/256.0, 1.0/256.0 );
				vec4 res = fract( depth * bit_shift );
				res -= res.xxyz * bit_mask;
				return res;

			}

			void main( void ) {

				float depth = gl_FragCoord.z / gl_FragCoord.w;
				// The packing requires depth in [0, 1] so we scale the clip-space z by 1000.
				// Ideally the scaler should match far plane distance.
				gl_FragColor = vec4( packDepth( depth / 1000.0 ) );

			}

		</script>

		<script id="combineVS" type="x-shader/x-vertex">

			varying vec2 vUv;

			void main()	{

				gl_Position = vec4( position, 1.0 );
				vUv = 0.5 + 0.5 * position.xy;

			}

		</script>

		<script id="combineFS" type="x-shader/x-fragment">

			uniform sampler2D accumTex;
			uniform sampler2D revealageTex;

			varying vec2 vUv;

			void main() {

				vec4 accum = texture2D( accumTex, vUv );
				float r = accum.a;
				accum.a = texture2D( revealageTex, vUv ).r;
				gl_FragColor = vec4( accum.rgb / max(accum.a, 1e-5), r );

			}

		</script>


		<script>

			// This is inversely proportional to world-space distance: 1 / <world-space size>.
			// Experiment to get good value for your scene.
			var SOFTEN_COEFF = 1.0 / 1.2;

			// Divisor to window size for rendertarget size. Larger values produce more error.
			var RENDERTARGET_SCALE = 1;

			var PARTICLE_SIZE = 10;

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var container, stats;
			var camera, scene, renderer, frameCounter = 0;
			var mouseX = 0, mouseY = 0;
			var angleX = 0, angleY = 0;

			var showOpaque = true;

			var windowHalfX, windowHalfY;
			var scaledWidth, scaledHeight;

			var particleUnif, particleCloud;
			var boxMesh;

			var rtDepth, depthMat;
			var rtAccum, accumMat, accumTex, revealageTex;

			var quadCam, quadMesh;

			init();
			animate();

			function init() {

				updateSizes();

				renderer = new THREE.WebGLRenderer( { antialias: false } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.autoClear = renderer.autoClearColor = renderer.autoClearDepth = renderer.autoClearStencil = false;
				renderer.sortObjects = false;

				camera = new THREE.PerspectiveCamera( 64, window.innerWidth / window.innerHeight, 0.1, 200 );
				scene = new THREE.Scene();

				opaqueRoot = new THREE.Object3D();
				scene.add( opaqueRoot );
				transparentRoot = new THREE.Object3D();
				scene.add( transparentRoot );

				// Depth rendertarget and depth rendering material

				rtDepth = new THREE.WebGLRenderTarget( scaledWidth, scaledHeight, {
					minFilter: THREE.LinearFilter,
					magFilter: THREE.LinearFilter,
					format: THREE.RGBAFormat,
					stencilBuffer: false
				} );

				depthMat = new THREE.ShaderMaterial( {
					vertexShader: document.getElementById( 'depthVS' ).textContent,
					fragmentShader: document.getElementById( 'depthFS' ).textContent,
					transparent: false,
// TODO: tsone: when is the opaque fix merged?
					blending: THREE.NoBlending 
				} );

				// Accumulation and revealage rendertarget

				var revealageParams = new THREE.TextureParams( {
					minFilter: THREE.LinearFilter,
					magFilter: THREE.LinearFilter,
					format: THREE.RGBFormat,
					type: THREE.FloatType,
					generateMipmaps: false
				} );

				rtAccum = new THREE.WebGLRenderTarget( scaledWidth, scaledHeight, {
					minFilter: THREE.LinearFilter,
					magFilter: THREE.LinearFilter,
					format: THREE.RGBAFormat,
					type: THREE.FloatType,
					generateMipmaps: false,
					extraColorTextures: [ revealageParams ],
					shareDepthFrom: rtDepth,
					stencilBuffer: false
				} );
				accumTex = rtAccum;
				revealageTex = rtAccum.extraColorTextures[ 0 ];

				// Particles

				var particleGeom = new THREE.Geometry();
				var particleTex = THREE.ImageUtils.loadTexture( "textures/sprites/circle.png" );
				particleTex.minFilter = particleTex.magFilter = THREE.LinearFilter;

				for ( var i = 0; i < 30; i ++ ) {

					var a = 8*Math.PI * i/29;
					var vertex = new THREE.Vector3();
					vertex.x = 2 * Math.cos( a );
					vertex.z = 2 * Math.sin( a );
					vertex.y = 4 * i/29 - 2;
					particleGeom.vertices.push( vertex );

				}

				particleUnif = {
					particleSize: { type: 'f', value: PARTICLE_SIZE },
					particleScale: { type: 'f', value: scaledHeight },
					near: { type: 'f', value: camera.near },
					far: { type: 'f', value: camera.far },
					invResolution: { type: 'v2', value: new THREE.Vector2( 1/scaledWidth, 1/scaledHeight ) },
					softenCoeff: { type: 'f', value: SOFTEN_COEFF }, 
					texture: { type: 't', value: particleTex },
					depthTex: { type: 't', value: rtDepth }
				};

				var particleMat = new THREE.ShaderMaterial( {
					uniforms: particleUnif,
					vertexShader: document.getElementById( 'particleVS' ).textContent,
					fragmentShader: document.getElementById( 'particleFS' ).textContent,
					depthTest: true,
					depthWrite: false,
					transparent: true,
					blending: THREE.CustomBlending,
					blendSrc: THREE.OneFactor,
					blendDst: THREE.OneFactor,
					blendSrcAlpha: THREE.ZeroFactor,
					blendDstAlpha: THREE.OneMinusSrcAlphaFactor

				} );

				particleCloud = new THREE.PointCloud( particleGeom, particleMat );
				transparentRoot.add( particleCloud );

				// Combine pass (full-screen quad)

				var combineUnif = {
					accumTex: { type: 't', value: accumTex },
					revealageTex: { type: 't', value: revealageTex }
				};
				var combineMat = new THREE.ShaderMaterial( {
					uniforms: combineUnif,
					vertexShader: document.getElementById( 'combineVS' ).textContent,
					fragmentShader: document.getElementById( 'combineFS' ).textContent,

					transparent: true,
					depthTest: false,
					depthWrite: false,
					blending: THREE.CustomBlending,
					blendSrc: THREE.OneMinusSrcAlphaFactor,
					blendDst: THREE.SrcAlphaFactor

				} );

				quadCam = new THREE.OrthographicCamera( -1, 1, 1, -1, 0, 1 );
				quadMesh = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2, 2 ), combineMat );

				// The box

				var boxTex = THREE.ImageUtils.loadTexture( 'textures/crate.gif' );
				boxTex.anisotropy = 4;
				var boxMat = new THREE.MeshBasicMaterial( { map: boxTex } );
				boxMesh = new THREE.Mesh( new THREE.BoxGeometry( 4, 4, 4 ), boxMat );
				boxMesh.position.z = 1;
				opaqueRoot.add( boxMesh );

				//

				onWindowResize();

				container = document.createElement( 'div' );
				document.body.appendChild( container );
				container.appendChild( renderer.domElement );

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				container.appendChild( stats.domElement );

				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				document.addEventListener( 'touchstart', onDocumentTouchStart, false );
				document.addEventListener( 'touchmove', onDocumentTouchMove, false );

				window.addEventListener( 'resize', onWindowResize, false );

			}

			function updateSizes() {

				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;

				scaledWidth = Math.floor( window.innerWidth / RENDERTARGET_SCALE );
				scaledHeight = Math.floor( window.innerHeight / RENDERTARGET_SCALE );

			}

			function onWindowResize() {

				updateSizes();

// TODO: tsone: is rendertarget scaling working?
/*
				rtDepth.width = scaledWidth;
				rtDepth.height = scaledHeight;
				rtDepth = rtDepth.clone();

				rtAccum.width = scaledWidth;
				rtAccum.height = scaledHeight;
				rtAccum = rtAccum.clone();

				particleUnif[ 'depthTex' ].value = rtDepth;
				particleUnif[ 'invResolution' ].value = new THREE.Vector2( 1/scaledWidth, 1/scaledHeight );
				particleUnif[ 'particleScale' ].value = scaledHeight;
*/
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function onDocumentMouseMove( event ) {

				mouseX = event.clientX - windowHalfX;
				mouseY = event.clientY - windowHalfY;

			}

			function onDocumentTouchStart( event ) {

				if ( event.touches.length == 1 ) {

					event.preventDefault();

					mouseX = event.touches[ 0 ].pageX - windowHalfX;
					mouseY = event.touches[ 0 ].pageY - windowHalfY;

				}
			}

			function onDocumentTouchMove( event ) {

				if ( event.touches.length == 1 ) {

					event.preventDefault();

					mouseX = event.touches[ 0 ].pageX - windowHalfX;
					mouseY = event.touches[ 0 ].pageY - windowHalfY;

				}

			}

			function animate() {

				requestAnimationFrame( animate );
				frameCounter ++;

				render();
				stats.update();

			}
			
			function toggleBox() {

				showOpaque = ! showOpaque;

			}

			function render() {

				var t = frameCounter / 60;

				angleX += (  0.5*Math.PI * mouseX / window.innerWidth - angleX ) * 0.1;
				angleY += (  0.5*Math.PI * mouseY / window.innerHeight - angleY ) * 0.1;

				camera.position.x = 6 * Math.sin(angleX) * Math.cos(angleY);
				camera.position.y = 6 * Math.sin(angleY);
				camera.position.z = -6 * Math.cos(angleX) * Math.cos(angleY);

				camera.lookAt( scene.position );

				boxMesh.position.x = 1.7 * Math.cos( t );
				boxMesh.rotation.y = t * 0.5;
				particleCloud.rotation.y = t * 0.25;

				// 1) Render opaque objects to depth texture using a depth write material.
				transparentRoot.visible = false;
				opaqueRoot.visible = true;
				scene.overrideMaterial = depthMat;
				renderer.setClearColor( 0xffffff, 1 );
				renderer.clearTarget( rtDepth, true, true, false );
				renderer.render( scene, camera, rtDepth );

				// 2) Render transparent objects to accumulation textures.
				transparentRoot.visible = true;
				opaqueRoot.visible = false;
				scene.overrideMaterial = null;
				renderer.setClearColor( 0x000000, 1 );
				renderer.clearTarget( rtAccum, true, false, false );
				renderer.render( scene, camera, rtAccum );

				// 3) Render scene with opaque only as background.
				transparentRoot.visible = false;
				opaqueRoot.visible = true;
				renderer.setClearColor( new THREE.Color().setHSL( ( 0.333*t ) % 1.0, 1.0, 0.4 ), 0 );
				renderer.setRenderTarget( null );
				renderer.clear( true, true, false );
				if ( showOpaque ) renderer.render( scene, camera );

				// 4) Render combine of transparent objects to opaque background.
				renderer.render( quadMesh, quadCam );

			}

		</script>
	</body>
</html>
