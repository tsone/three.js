<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - weighted blended order-independent transparency</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				background-color: #000000;
				margin: 0px;
				overflow: hidden;
				font-family:Monospace;
				font-size:13px;
				text-align:center;
				font-weight: bold;
				text-align:center;
			}

			a {
				color:#0078ff;
			}

			#info {
				color:#fff;
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
				z-index:100;
			}

		</style>
	</head>
	<body>

		<div id="info">
			<a href="http://threejs.org" target="_blank">three.js</a> - webgl weighted blended order-independent transparency - <a href="http://jcgt.org/published/0002/02/09/" target="_blank">paper</a><br/>
			<input type="checkbox" checked onclick="toggleBox();">show opaque background</>
		</div>

		<script src="../build/three.js"></script>

		<script src="js/Detector.js"></script>
		<script src="js/loaders/MTLLoader.js"></script>
		<script src="js/loaders/OBJMTLLoader.js"></script>
		<script src="js/libs/stats.min.js"></script>

		<script id="particleVS" type="x-shader/x-vertex">

			uniform float particleScale;
			uniform float particleSize;
			uniform float far;
			uniform float near;

			varying float depth;

			void main()
			{

				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				depth = gl_Position.z * (far-near) / far + near;
				gl_PointSize = particleSize * particleScale / gl_Position.z;

			}

		</script>

		<script id="particleFS" type="x-shader/x-fragment">

			#extension GL_EXT_draw_buffers : require

			uniform sampler2D texture;
			uniform sampler2D depthTex;
			uniform vec2 invResolution;
			uniform float softenCoeff;

			varying float depth;

			float unpackDepth( const in vec4 rgba_depth ) {

				const vec4 bit_shift = vec4( 1.0 / ( 256.0*256.0*256.0 ), 1.0 / ( 256.0*256.0 ), 1.0 / 256.0, 1.0 );
				float depth = dot( rgba_depth, bit_shift );
				return depth;

			}

			void main( void ) {

				vec4 color = texture2D( texture, gl_PointCoord );
				// Depth was encoded as 1/1000, so we need to scale it back.
				float bgDepth = 1000.0 * unpackDepth( texture2D( depthTex, gl_FragCoord.xy * invResolution ) );
//				float soften = min( softenCoeff * (bgDepth - depth), 1.0 );
				float soften = clamp( softenCoeff * (bgDepth - depth), 0.0, 1.0 );
				// Apply alpha to RGB (not premultiplied) and soften. Particles are max. 50% opaque.
//				color = soften*color.a * vec4( color.rgb, 1.0 ); 
//				color.rgb = clamp( (color.rgb - 76.0/256.0) / (180.0/256.0) , 0.0, 1.0);
//				color.rgb = clamp( (color.rgb - 16.0/256.0) / 2.0 , 0.0, 1.0);
				color.rgb = clamp( (color.rgb - 0.0/256.0) / 4.0 , 0.0, 1.0);
//				color.rgb = vec3( 0.0 );
				color *= soften; 
//				float w = 1e-8 + (1.0 - 1e-8) * pow( 1.0 + depth, -5.0 );
//				float w = pow( 1.0 + depth, -5.0 );
				float w = 1.0 / depth;
//				float w = 1.0;
				gl_FragData[0] = vec4( w * color.rgb, color.a );
				gl_FragData[1].r = w * color.a;

			}

		</script>

		<script id="depthVS" type="x-shader/x-vertex">

			void main()
			{
				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			}

		</script>

		<script id="depthFS" type="x-shader/x-fragment">

			vec4 packDepth( const in float depth ) {

				const vec4 bit_shift = vec4( 256.0*256.0*256.0, 256.0*256.0, 256.0, 1.0 );
				const vec4 bit_mask = vec4( 0.0, 1.0/256.0, 1.0/256.0, 1.0/256.0 );
				vec4 res = fract( depth * bit_shift );
				res -= res.xxyz * bit_mask;
				return res;

			}

			void main( void ) {

				float depth = gl_FragCoord.z / gl_FragCoord.w;
				// The packing requires depth in [0, 1] so we scale the clip-space z by 1000.
				// Ideally the scaler should match far plane distance.
				gl_FragColor = vec4( packDepth( depth / 1000.0 ) );

			}

		</script>

		<script id="combineVS" type="x-shader/x-vertex">

			varying vec2 vUv;

			void main()	{

				gl_Position = vec4( position, 1.0 );
				vUv = 0.5 + 0.5 * position.xy;

			}

		</script>

		<script id="combineFS" type="x-shader/x-fragment">

			uniform sampler2D accumTex;
			uniform sampler2D revealageTex;

			varying vec2 vUv;

			void main() {

				vec4 accum = texture2D( accumTex, vUv );
				float r = accum.a;
				accum.a = texture2D( revealageTex, vUv ).r;
//				gl_FragColor = vec4( accum.rgb / accum.a, r );
				gl_FragColor = vec4( accum.rgb / max(accum.a, 1e-6), r );

			}

		</script>


		<script>

			// This is inversely proportional to world-space distance: 1 / <world-space size>.
			// Experiment to get good value for your scene.
			var SOFTEN_COEFF = 1.0 / 1.0;

			// Divisor to window size for rendertarget size. Larger values produce more error.
			var RENDERTARGET_SCALE = 2;

			var PARTICLE_SIZE = 2;

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var container, stats;
			var camera, scene, renderer, frameCounter = 0;
			var mouseX = 0, mouseY = 0;
			var angleX = 0, angleY = 0;

			var showOpaque = true;

			var windowHalfX, windowHalfY;
			var scaledWidth, scaledHeight;

			var particleUnif, particleCloud;
			var boxMesh;

			var rtDepth, depthMat;
			var rtAccum, accumMat, accumTex, revealageTex;

			var quadCam, quadMesh;

			var pointLight;

			var loader = new THREE.OBJMTLLoader();
			loader.load( 'obj/sponza/sponza.obj', 'obj/sponza/sponza.mtl', function ( object ) {
					object.traverse( function ( child ) {

						if ( child instanceof THREE.Mesh ) {

							child.geometry.computeVertexNormals( true );
							child.material.shading = THREE.SmoothShading;
							child.material.bumpScale = 0.05;
							if ( child.material.map )
								child.material.map.anisotropy = 8;
							if ( child.material.bumpMap )
								child.material.bumpMap.anisotropy = 8;

						}

					} );
					opaqueRoot.add( object );
				},
				function ( xhr ) { console.log( (xhr.loaded / xhr.total * 100) + '% loaded' ); },
				function ( xhr ) { console.log( 'An error happened' ); }
			);

			init();
			animate();

			function init() {

				updateSizes();

				renderer = new THREE.WebGLRenderer( { antialias: false } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.autoClear = renderer.autoClearColor = renderer.autoClearDepth = renderer.autoClearStencil = false;
				renderer.sortObjects = false;

				camera = new THREE.PerspectiveCamera( 64, window.innerWidth / window.innerHeight, 0.1, 200 );
				scene = new THREE.Scene();

				opaqueRoot = new THREE.Object3D();
				scene.add( opaqueRoot );
				transparentRoot = new THREE.Object3D();
				scene.add( transparentRoot );

				// Lights
				var ambient = new THREE.AmbientLight( 0x3f3f3f );
				scene.add( ambient );

				pointLight = new THREE.PointLight( 0xd0d0d0 );
				pointLight.position.y = 6;
				scene.add( pointLight );

				// Depth rendertarget and depth rendering material

				rtDepth = new THREE.WebGLRenderTarget( scaledWidth, scaledHeight, {
					minFilter: THREE.NearestFilter,
					magFilter: THREE.NearestFilter,
					format: THREE.RGBAFormat,
					stencilBuffer: false
				} );

				depthMat = new THREE.ShaderMaterial( {
					vertexShader: document.getElementById( 'depthVS' ).textContent,
					fragmentShader: document.getElementById( 'depthFS' ).textContent,
					transparent: false,
// TODO: tsone: when is the opaque fix merged?
					blending: THREE.NoBlending 
				} );

				// Accumulation and revealage rendertarget

				var revealageParams = new THREE.TextureParams( {
					minFilter: THREE.NearestFilter,
					magFilter: THREE.NearestFilter,
					format: THREE.RGBFormat,
					type: THREE.FloatType,
					generateMipmaps: false
				} );

				rtAccum = new THREE.WebGLRenderTarget( scaledWidth, scaledHeight, {
					minFilter: THREE.NearestFilter,
					magFilter: THREE.NearestFilter,
					format: THREE.RGBAFormat,
					type: THREE.FloatType,
					generateMipmaps: false,
					extraColorTextures: [ revealageParams ],
					shareDepthFrom: rtDepth,
					stencilBuffer: false
				} );
				accumTex = rtAccum;
				revealageTex = rtAccum.extraColorTextures[ 0 ];

				// Particles

				var particleGeom = new THREE.Geometry();
//				var particleTex = THREE.ImageUtils.loadTexture( "textures/sprites/circle.png" );
				var particleTex = THREE.ImageUtils.loadTexture( "textures/smoke2.png" );
				particleTex.minFilter = particleTex.magFilter = THREE.LinearFilter;

				for ( var i = 0; i < 30; i ++ ) {

					var a = 8*Math.PI * i/29;
					var vertex = new THREE.Vector3();
					var r = 0.9 + 1.0 * i/29;
					vertex.x = r * Math.cos( a );
					vertex.z = r * Math.sin( a );
					vertex.y = 5.0 * i/29 + 0.5;
					particleGeom.vertices.push( vertex );

				}

//				particleGeom.vertices.push( new THREE.Vector3(0,0,0) );

				particleUnif = {
					particleSize: { type: 'f', value: PARTICLE_SIZE },
					particleScale: { type: 'f', value: scaledHeight },
					near: { type: 'f', value: camera.near },
					far: { type: 'f', value: camera.far },
					invResolution: { type: 'v2', value: new THREE.Vector2( 1/scaledWidth, 1/scaledHeight ) },
					softenCoeff: { type: 'f', value: SOFTEN_COEFF }, 
					texture: { type: 't', value: particleTex },
					depthTex: { type: 't', value: rtDepth }
				};

				var particleMat = new THREE.ShaderMaterial( {
					uniforms: particleUnif,
					vertexShader: document.getElementById( 'particleVS' ).textContent,
					fragmentShader: document.getElementById( 'particleFS' ).textContent,
					depthTest: true,
					depthWrite: false,
					transparent: true,
					blending: THREE.CustomBlending,
					blendSrc: THREE.OneFactor,
					blendDst: THREE.OneFactor,
					blendSrcAlpha: THREE.ZeroFactor,
					blendDstAlpha: THREE.OneMinusSrcAlphaFactor

				} );

				particleCloud = new THREE.PointCloud( particleGeom, particleMat );
				transparentRoot.add( particleCloud );
//				pointLight.add( particleCloud );

				// Combine pass (full-screen quad)

				var combineUnif = {
					accumTex: { type: 't', value: accumTex },
					revealageTex: { type: 't', value: revealageTex }
				};
				var combineMat = new THREE.ShaderMaterial( {
					uniforms: combineUnif,
					vertexShader: document.getElementById( 'combineVS' ).textContent,
					fragmentShader: document.getElementById( 'combineFS' ).textContent,

					transparent: true,
					depthTest: false,
					depthWrite: false,
					blending: THREE.CustomBlending,
					blendSrc: THREE.OneMinusSrcAlphaFactor,
					blendDst: THREE.SrcAlphaFactor

				} );

				quadCam = new THREE.OrthographicCamera( -1, 1, 1, -1, 0, 1 );
				quadMesh = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2, 2 ), combineMat );

				// The box

				var boxTex = THREE.ImageUtils.loadTexture( 'textures/crate.gif' );
				boxTex.anisotropy = 4;
				var boxMat = new THREE.MeshBasicMaterial( { map: boxTex } );
				boxMesh = new THREE.Mesh( new THREE.BoxGeometry( 4, 4, 4 ), boxMat );
				boxMesh.position.z = 1;
//				opaqueRoot.add( boxMesh );

				//

				onWindowResize();

				container = document.createElement( 'div' );
				document.body.appendChild( container );
				container.appendChild( renderer.domElement );

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				container.appendChild( stats.domElement );

				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				document.addEventListener( 'touchstart', onDocumentTouchStart, false );
				document.addEventListener( 'touchmove', onDocumentTouchMove, false );

				window.addEventListener( 'resize', onWindowResize, false );

			}

			function updateSizes() {

				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;

				scaledWidth = Math.floor( window.innerWidth / RENDERTARGET_SCALE );
				scaledHeight = Math.floor( window.innerHeight / RENDERTARGET_SCALE );

			}

			function onWindowResize() {

				updateSizes();

// TODO: tsone: is rendertarget scaling working?
/*
				rtDepth.width = scaledWidth;
				rtDepth.height = scaledHeight;
				rtDepth = rtDepth.clone();

				rtAccum.width = scaledWidth;
				rtAccum.height = scaledHeight;
				rtAccum = rtAccum.clone();

				particleUnif[ 'depthTex' ].value = rtDepth;
				particleUnif[ 'invResolution' ].value = new THREE.Vector2( 1/scaledWidth, 1/scaledHeight );
				particleUnif[ 'particleScale' ].value = scaledHeight;
*/
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function onDocumentMouseMove( event ) {

				mouseX = event.clientX - windowHalfX;
				mouseY = event.clientY - windowHalfY;

			}

			function onDocumentTouchStart( event ) {

				if ( event.touches.length == 1 ) {

					event.preventDefault();

					mouseX = event.touches[ 0 ].pageX - windowHalfX;
					mouseY = event.touches[ 0 ].pageY - windowHalfY;

				}
			}

			function onDocumentTouchMove( event ) {

				if ( event.touches.length == 1 ) {

					event.preventDefault();

					mouseX = event.touches[ 0 ].pageX - windowHalfX;
					mouseY = event.touches[ 0 ].pageY - windowHalfY;

				}

			}

			function animate() {

				requestAnimationFrame( animate );
				frameCounter ++;

				render();
				stats.update();

			}
			
			function toggleBox() {

				showOpaque = ! showOpaque;

			}

			function render() {

				var t = frameCounter / 60;

				angleX += (  0.5*Math.PI * mouseX / window.innerWidth - angleX ) * 0.1;
				angleY += (  0.5*Math.PI * mouseY / window.innerHeight - angleY ) * 0.1;

				camera.position.x = 6 * Math.sin(angleX) * Math.cos(angleY);
				camera.position.y = 6 * Math.sin(angleY);
				camera.position.z = -6 * Math.cos(angleX) * Math.cos(angleY);

				camera.lookAt( scene.position );

				boxMesh.position.x = 1.7 * Math.cos( t );
				boxMesh.rotation.y = t * 0.5;
				particleCloud.rotation.y = t * 3.0;
				particleCloud.position.x = -9 * Math.sin( t * 0.3 );
				particleCloud.position.z = 4 * Math.sin( t * 0.6 );

//				pointLight.position.x = 10 * Math.cos( 2 * t );

				// 1) Render opaque objects to depth texture using a depth write material.
				transparentRoot.visible = false;
				opaqueRoot.visible = true;
				scene.overrideMaterial = depthMat;
				renderer.setClearColor( 0xffffff, 1 );
				renderer.clearTarget( rtDepth, true, true, false );
				renderer.render( scene, camera, rtDepth );

				// 2) Render transparent objects to accumulation textures.
				transparentRoot.visible = true;
				opaqueRoot.visible = false;
				scene.overrideMaterial = null;
				renderer.setClearColor( 0x000000, 1 );
//				renderer.setClearColor( new THREE.Color(1e-9, 1e-9, 1e-9), 1 );
				renderer.clearTarget( rtAccum, true, false, false );
				renderer.render( scene, camera, rtAccum );

				// 3) Render scene with opaque only as background.
				transparentRoot.visible = false;
				opaqueRoot.visible = true;
//				renderer.setClearColor( new THREE.Color().setHSL( ( 0.333*t ) % 1.0, 1.0, 0.4 ), 0 );
				renderer.setRenderTarget( null );
				renderer.clear( true, true, false );
				if ( showOpaque ) renderer.render( scene, camera );

				// 4) Render combine of transparent objects to opaque background.
				renderer.render( quadMesh, quadCam );

			}

		</script>
	</body>
</html>
